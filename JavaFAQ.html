  Type of DATA

boolean: хранит значение true или false
byte: хранит целое число от -128 до 127 и занимает 1 байт
short: хранит целое число от -32768 до 32767 и занимает 2 байта
int: хранит целое число от -2147483648 до 2147483647 и занимает 4 байта
long: хранит целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт
float: хранит число с плавающей точкой от -3.4*1038 до 3.4*1038 и занимает 4 байта
double: хранит число с плавающей точкой от ±4.9*10-324 до ±1.8*10308 и занимает 8 байт
var приймає любий обєкт, але має бути ініціалізований при обявленні}
char: символ

instanceof == то саме шо ``is`` в С#
___________________________________________________________________________________________________________________
    final

змінні - не можна змінювати, ініціалізація при створенні;
методи - не можна переоприділяти;
класи - не можна наслідувати;
___________________________________________________________________________________________________________________
class
коли клас абстрактний, то він просто має мати 1 абстрактну функцію і не може мати обєктів своїх.
але поля і інші методи може мати
___________________________________________________________________________________________________________________
interface
за допомогою default - можна роботи метод, який матиме своє тіло, яке юзається тіки тоді, коли не
реалізували той метод

також, методи може бути static, як в класах і мати своє тіло

також метод може бути private, але чисто для юзання всередині інтерфейсу
___________________________________________________________________________________________________________________
ENUM
в собі може мати конструктор(який йде як прайвет) і різні методи
має метод values() який повертає всі константи данного enum
ordinal() - повертає номер за яким стоїть певна константа 

enum Color{
    RED("#FF0000"), BLUE("#0000FF"), GREEN("#00FF00");
    private String code;
    Color(String code){
        this.code = code;
    }
    public String getCode(){ return code;}
}

 System.out.println(Color.RED.getCode());        // #FF0000
___________________________________________________________________________________________________________________
виводити текст можна як
System.out.print; - вивід без абзацу
System.out.println; - вивід з абзацом
System.out.printf;  - вивід як в С , через %     System.out.printf("%25.3f \n%25.9f", a, b)

___________________________________________________________________________________________________________________
Scanner in = new Scanner(System.in);

передача в параметри методу невідому кількість інтів
c# - params int[] b
java - int ...b
ОБОВЯЗКОВО ОБЯВЛЯТИ ВКІНЦІ!
___________________________________________________________________________________________________________________
функцию округления
int b = (int)Math.round(a);
___________________________________________________________________________________________________________________
EXCEPTION ex
ex.printStackTrace() -выводу на консоль стека трассировки ошибки с помощью метода
ex.GetMessage() - сообщение об исключении 
___________________________________________________________________________________________________________________

GENERICS

class Account<T>

interface Accountable<T>

public <T> void print(T[] items)
    printer.<Integer>print(numbers);
    
Для установки ограничения после универсального параметра
ставится слово extends, после которого указывается базовый класс ограничения:
class Transaction<T extends Account>{ }

можно установить сразу несколько ограничений
class Transaction<T extends Person & IAccountable>{}
___________________________________________________________________________________________________________________
  
Object - це клас всіх класів
якщо обєкти рівні один одному, тобто equals = true, то і hashcode у них однаковий, в іншову випадку - ексепшн
string він є неіміняємим класом, тобто immutable
а клас StringBuilder - він є mutable, тобто може змінюватись під час виконання
java має пізднє звязування, тому всі методи по замовчуванню віртуальні 

_____________Колекції_______________
1)Коллекції
    1.1) LinkedList - двухсвязний список ( кращий для додавання, видаляння)
    1.7) ArrayList - список на основі масиву ( кращий для доступу)
    1.8) Vector - динамічний масив з методами списку
    
    1.2)Set  список без дублікатів
    1.3)Queue просто очередь
    1.4)Deque двунаправлена очередь
    1.5)Map - ключ значення
    1.6)HashMap - швидка реалізація Map але  ключі унікальні ( без повторень)
       хешмап це масив, а індекс оприділяється по хешкоду ключа і довжині масиву
    
    1.6.1)LinkedHashMap - упорядкована реалізація HashMap (красно чорного дерева)
     это упорядоченная реализация хэш-таблицы. Здесь, в отличии от HashMap, 
     порядок итерирования равен порядку добавления элементов.
    
    1.6) HashSet - оснований на HashMap,а тут ще і данні унікальні
    
    1.6.2) LinkedHashSet - упорядкований HashSet

ArrayList: простой список объектов

LinkedList: представляет связанный список

ArrayDeque: класс двунаправленной очереди, в которой мы можем произвести вставку и удаление как в начале коллекции, так и в ее конце

HashSet: набор объектов или хеш-множество, где каждый элемент имеет ключ - уникальный хеш-код

TreeSet: набор отсортированных объектов в виде дерева

LinkedHashSet: связанное хеш-множество

PriorityQueue: очередь приоритетов

HashMap: структура данных в виде словаря, в котором каждый объект имеет уникальный ключ и некоторое значение

TreeMap: структура данных в виде дерева, где каждый элемент имеет уникальный ключ и некоторое значение
     
     
_____________EXCEPTION______________
   1)Exception (cheked) тре обробляти
        SQLException
        IOException
    RuntimeException(uncheked) 
        IndexOutOfBoundsException
        ArithmeticException
        ClassCatException
        NoSuchElementException
   
   2)Error (uncheked), не тре їх обробляти в блоці трай кетч
        VirtualMachineError
           StackOverflowError
           OutOfMemoryError
       
    try with resources?
        це інтерфейс AutoCloseable
    компілятор сам неявно створює finally і закриває ресурс
    
    
_________THREADING_______________
    через інтерфейс Runnable або через клас Thread
    
   1) class SomeTh implements Runnable
        public void run()
        {
            //code
        }
    АБО
   2) сlass SomeThre extends Thread
        @Override
        public void run()
        {
            //code
        }
        
    public static void main(String[] args)
   1)   
        Thread th = new Thread(new Someth())
        th.start();
        
   2)   SomeThre sm = new SomeThre();
        sm.start();
        
        
Шоб контролювати коли який потік. тре їх синхронізувати
 - synchronized + треба заглушку як lock в c#, якийсь обєкт не примітивного типу
 - wait/notify 
 wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор,
пока другой поток не вызовет метод notify()
notify(): продолжает работу потока, у которого ранее был вызван метод wait()
 - join  так як в с++
 - Семафоры як в шарпі
 - класи з пакета java.util.concurrent
 
 _______Stream API____аналог LINQ
 
  cities.stream() // получаем поток
            .filter(s->s.length()==6) // применяем фильтрацию по длине строки
            .forEach(s->System.out.println(s)); // выводим отфильтрованные строки на консоль
            sorted()  // сортуємо
    
Метод skip(long n) используется для пропуска n элементов. Этот метод возвращает новый поток, 
в котором пропущены первые n элементов.

Метод limit(long n) применяется для выборки первых n элементов потоков. 
Этот метод также возвращает модифицированный поток, в котором не более n элементов.
 
Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта Stream 
 метод parallel. Кроме того, можно также использовать метод parallelStream() интерфейса 
 Collection для создания параллельного потока из коллекции.

phones.parallelStream()
    .sorted()
    .forEachOrdered(s->System.out.println(s));
    
    
 _______PATTERN______
 
 GoF Gang of Four
 1) creational
 2)structural
 3)behavior
 
 MVC
 Model - це дані нашої програми, описується стан
 View - відповідає за відображення, і реагує на зміну моделі, сама підтягує
 Controller - реагує на зміни користувача і оповіщаю модель що тре міняти
 
 MVVM
 Model
 Viev 
 ModelView
 
 MVP
 Model
 Viev 
 Presenter
 
 SOLID 
 S- Single responsibility principle - кожен обєкт має виконувати лише один обовязок
 O- Open/closed principle(класи відкриті для розширення, закриті для редагування)
 L- Liskov substitution principle(Об'єкти в програмі можуть бути заміненими їх нащадками без зміни коду програми.)
 I- Interface segregation principle (Багато спеціалізованих інтерфейсів краще за один універсальний)
 D- Dependency inversion principle(Залежності всередині системи будуються на основі абстракцій, що не повинні 
    залежати від деталей; навпаки, деталі мають залежати від абстракцій.)

______Потоки ввода-вывода. Работа с файлами________

В основе всех классов, управляющих потоками байтов, находятся два абстрактных класса:
InputStream (представляющий потоки ввода) и OutputStream (представляющий потоки вывода)
Но поскольку работать с байтами не очень удобно, то для работы с потоками символов были добавлены
абстрактные классы Reader (для чтения потоков символов) и Writer (для записи потоков символов).

_____Seryalization_____
Сразу надо сказать, что сериализовать можно только те объекты, которые реализуют интерфейс 
Serializable. Этот интерфейс не определяет никаких методов, просто он служит указателем системе,
 что объект, реализующий его, может быть сериализован.


Для сериализации объектов в поток используется класс ObjectOutputStream. Он записывает данные 
в поток.
Класс ObjectInputStream отвечает за обратный процесс - чтение ранее сериализованных данных из 
потока. В конструкторе он принимает ссылку на поток ввода:

______lambda_func______
Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку ->. Этот
 оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров 
 выражения, а правая собственно представляет тело лямбда-выражения, где выполняются все действия.

Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного 
в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать
 только один единственный метод без реализации.

__________SQL________

    ____ Join ____
    1) Inner join - зєднує все спільне цих двох таблиць  
    2)Left outer join - всі строки зліва, якщо справа нема співпадіння по цій строці, то там null
    3)Right outer join - всі строки справа, якщо зліва нема співпадіння по цій строці, то там null 
    4)Full outer join - це left+right join
    5)croos join - кожна строка з першої таблиці зєднується з кожною строкою другої
    
    SLQ Injection
    

___________SPRING (вивчити сервлєти спочатку)____________________

    -dependency injection
    -inversion of control  -> треба мнімалізувати звязок між шарами програми, і завязуватись на абстраціях 
        (інтерфейсі, абстрактні класи) щоб можна було легко замінити шось, не затронувши інший рівень 
    
    bean - це обєкти в спрінгу
    
    област видимості обєктів буває
        -singleton (default) - один і той самий бін
        -prototype - новий бін кожен раз
        -request - кожен раз новий бін на НТТР запит і видаляється потім
        -session - кожен раз новий бін на на сесію і видаляється потім вкінці
        -globalsession - вертаю новий бін, на час глобальної сесії
        -application -> 

_____________Hibernate_____________________

  - технологія для рішення задач обєктно реляційного мапінга
  - це прослойка між кодом і базами данних
     отримувати надсилати бази даних
     які класи на які таблиці відображаються

    
__________________________________________________________________________________________________________________

Servlets

Перенаправлення ( без зміни адреси)
{
    ServletContext context = getServletContext();
    RequestDispatcher dispatcher = context.getRequestDispatcher("/notfound.html");
    dispatcher.forward(req,resp);
}
переадресація ( зі зміною адреси)
{
    resp.sendRedirect(req.getContextPath() + "/notfound.html");
}

__________________________________________________________________________________________________________________
***JDBC***

берем Connection from DriverManager

3 types of statement
- Statement
- PreparedStatement
- CallableStatement

і в них пишем SQL запит
**********************************************
всі вони видають ResultSet з якого дістаємо результати

також ми можемо редагувати напряму базу данних, якщо після квері добавимо ResultSet.TYPE_SCROLL_SENSITIVE i ResultSet.CONCUR_WRITE..
