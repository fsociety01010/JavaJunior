<pre>

    ************************************************
    ******************Spring************************
    ************************************************
    
        -dependency injection
        -inversion of control  -> треба мнімалізувати звязок між шарами програми, і завязуватись на абстраціях
            (інтерфейсі, абстрактні класи) щоб можна було легко замінити шось, не затронувши інший рівень
    
        bean - це обєкти в спрінгу
    
    
        XML
    
        в XML бін має
        <bean id="human" class="java.org.human" scope="@see..." 
            factory-method="якщо в нас нема конструктора,а обєкт створюється через статік метод, то ми маємо цю штуку..."
            parent="бін, від якого хочемо стягнути настройки і тдп(використовуються, коли в бінах одинакові настройки)"
                той факт, шо бін стягує інфу з парента, не означає шо він його екстендить, він просто бере інфу
    
            depends-on="настройка, при якій ініціалізація почнеться,коли появиться цей обєкт(бін)"
            lazy-init="true - пізня ініціалізація,стартане тіки тоді, коли запроситься бін в контексті"
    
            >
            
            <constructor-arg 
                value="значення" 
                index="порядковий номер агрумента" 
                type="тип данних" 
                ref="посилання на інший бін"
                init-method="метод,який стартує після створення біна" 
                destroy-method="метод,який стартує при закриванні контекста"/>
            <constructor-arg>
                <bean class="java.util.Date" /> //внутрішній бін
            </constructor-arg>
    
        </bean>
    
        @Annotation
    
        @Configuration (ставимо, там де буде ApplicationContext)
            @ComponentScan (basePackage= {"packege with annotation"})
        @Bean
        @Autowired // автоматично ставиться на єдиний конструктор, якщо немає інших

        @Qualifier("name") /пишемо, коли хочемо заавтовайрити певний бін! аналогічно анатоцію(або в анотації компонента) ставим до біна!

        @Component
            @Service
            @Repository
            
    
        ***SCOPE***
        -singleton - один і той самий бін завжди
        -prototype - кожен раз новий бін
    
        ***Web SCOPE***
        -request -> кожен раз новий бін на НТТР запит і видаляється потім
        -session -> кожен раз новий бін на на сесію і видаляється потім вкінці
        -globalsession -> вертаю новий бін, на час глобальної сесії
        -application ->
        -webSocket
    
        ****LifeCycle***
        @PostConstruct
        @InitMethod
        @PreDestroy
        @DestroyMethod
    
    
        ExpressionLanguage задається як #{ }
    
    
        далі, створюємо апп контекст в програмі
    
        ApplicationContext ctx = new ClassPathXmlApplicationContext("spring.xml");
        Human human = (Human) ctx.getBean("human");
    
    
    ************************************************
    ****************Spring BOOT*********************
    ************************************************
    
    in main we use 
    @SpringBootApplication
    and in main method Run
        SpringApplication.run(Main.class,args)
    
    
    @Autowired
         де хочемо заінжектити залежність
    
    *****@Component:
    @RestController or @Controller
        Ставиться на котроллер
    
        @RequestMapping("/students")  // адрес по якому буде запит,перед класом
        @RequestMapping(method = RequestMethod.GET) //перед методом і показує шо вертається
    
        @RequestMapping(method = RequestMethod.DELETE,value = "/{id}") // value - вказуємо дальнейший запит, який передамо метод
        public void deleteStudentById(@PathVariable("id") int id)   // @PathVariable("id") - передача реквесту з запиту в метод
    
    @Service
        Ставиться на сервіс
    
    @Repository 
        Ставиться на ДАОшку
    
    
    
    
    ************************************************
    ******************JUnit*************************
    ************************************************
    
    @RunWith(JUnitParamsRunner.class) - to run test class with param
    
    @Test
    @Param(method = "getArray")
    
    if we expected some exception,than use 
    @Test(expected = ExceptionClass.class)
    
    @Before
    @After
    
    @BeforeClass
    @AfterClass

</pre>